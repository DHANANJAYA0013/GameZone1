<!doctype html>
  <meta charset=utf-8>
  <title>Tetr.js</title>
  <!-- <link rel=stylesheet href=style.css> -->
  <style>
    @font-face {
  font-family: 'Lato';
  font-style: normal;
  font-weight: 400;
  src: local('Lato Regular'), local('Lato-Regular'), url(https://fonts.gstatic.com/s/lato/v11/MDadn8DQ_3oT6kvnUq_2r_esZW2xOQ-xsNqO47m55DA.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
@font-face {
  font-family: 'Source Sans Pro';
  font-style: normal;
  font-weight: 400;
  src: local('Source Sans Pro'), local('SourceSansPro-Regular'), url(https://fonts.gstatic.com/s/sourcesanspro/v9/ODelI1aHBYDBqgeIAH2zlJbPFduIYtoLzwST68uhz_Y.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
@font-face {
  font-family: 'Source Sans Pro';
  font-style: normal;
  font-weight: 900;
  src: local('Source Sans Pro Black'), local('SourceSansPro-Black'), url(https://fonts.gstatic.com/s/sourcesanspro/v9/toadOcfmlt9b38dHJxOBGIq-Fb0zf838trI74uojZQY.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
@font-face {
  font-family: 'FontAwesome';
  src: url('fontawesome-webfont.eot?v=3.0.1');
  src: url('fontawesome-webfont.eot?#iefix&v=3.0.1') format('embedded-opentype'),
    url('fontawesome-webfont.woff?v=3.0.1') format('woff'),
    url('fontawesome-webfont.ttf?v=3.0.1') format('truetype');
  font-weight: normal;
  font-style: normal;
}
/* General */
html {
  font-size: 1em;
}
body {
  font: 1em 'Source Sans Pro';
  margin: 0;
  background: #000;
  background-size: cover;
  color: #fff;
  background-image: url("{{url_for('static',filename='images/wood2.jpg' )}}");
}
a {
  color: #fff;
  text-decoration: none;
}
table {
  border-collapse: collapse;
  border-spacing: 0;
}
th {
  padding: 0;
  font-weight: normal;
}
td {
  padding: 0;
}

/* Header */
h1 {
  color: #fff;
  font-size: 2rem;
  margin: 0.65em 0;
}
h3 {
  margin: 0;
  text-transform: uppercase;
  font-weight: normal;
  text-align: center;
}
nav > ul {
  margin: 0;
  padding: 0;
}
.button,
nav li {
  display: block;
}
.button,
nav a {
  font: 1.25rem 'Lato';
  display: inline-block;
  width: 50%;
  color: #fff;
  border: 2px solid #fff;
  cursor: pointer;
  border-radius: 5px;
  padding: 0.3rem 0.6rem 0.4rem;
  margin: 0.5em;
  background: #000;
}
.button {
  margin: 0;
}
[class^="icon-"],
[class*=" icon-"] {
  font-family: FontAwesome;
  font-weight: normal;
  font-style: normal;
  text-decoration: inherit;
  margin: 0 0.4em 0 0;
  -webkit-font-smoothing: antialiased;
}
.icon-cog:before{content:'\f021'}

/* Content */
#content {
  display: table;
  margin: auto;
  background: rgba(0,0,0,0.7);
}

/* Canvases */
#sprite {
  display: none;
}
/*#bg {
  position: fixed;
  top:0;
  left:0;
  height:100%;
  width:100%;
  z-index: -1;
  opacity: 0;
  transition: opacity .5s ease-in;
}*/
#bg {
  position: fixed;
  top:0;
  left:0;
  height:100%;
  width:100%;
  z-index: -1;
}
#a {
  position: relative;
  overflow: hidden;
  float: left;
}
#b {
  border: 1px solid #fff;
  box-shadow: 0 0 20px rgba(255,255,255,0.5);
  position: relative;
  overflow: hidden;
  float: left;
  z-index: 3;
}
#c {
  padding: 0 0.5em;
  position: relative;
  overflow: hidden;
  float: left;
}
  #bgStack {
    background: #000;
    position: absolute;
    z-index: 2;
  }
  #hold,
  #preview,
  #stack {
    position: absolute;
    z-index: 2;
  }
  #active {
    position: absolute;
    z-index: 3;
  }
  #msg {
    font: 900 4rem 'Source Sans Pro', sans-serif;
    font-size: 4rem;
    color: #fff;
    position: absolute;
    text-align: center;
    width: 100%;
    line-height: 642px;
    margin: 0;
    z-index: 4;
  }

#d {
  float: left;
}

/* Stats */
#stats {
  display: block;
  position: absolute;
}
#stats tbody {
  display: block;
}
#stats tr {
  display: block;
  width: 100%;
  padding: 0 0.5rem;
}
#stats th {
  text-transform: uppercase;
  display: inline-block;
  width: 100%;
  vertical-align: top;
}
#stats td {
  font-size: 280%;
  font-weight: 900;
  text-align: center;
  line-height: 1;
  display: inline-block;
  width: 100%;
}
#time {
  text-align: center;
  font-weight: 900;
  font-size: 1.125em;
  display: block;
}

/* Menus */
.menu {
  text-align: center;
  width: 100%;
  height: 100%;
  overflow-y: auto;
  overflow-x: hidden;
  margin-top: -200%;
  position: absolute;
  background: #000;
  background: rgba(0,0,0,0);
  top: 0;
  z-index: 50;
  opacity: 0;
  /*-webkit-transition: opacity .4s ease-in-out;
     -moz-transition: opacity .4s ease-in-out;
       -o-transition: opacity .4s ease-in-out;*/
          transition: opacity .8s ease-out,
                      background .4s ease-out .3s,
                      margin .4s ease-out;
}
.on {
  background: rgba(0,0,0,0.8);
  opacity: 1;
  margin: 0;
}

/* Controls */
#controls {
  margin: 0 auto 1em;
}
#controls th {
  font-weight: bold;
  text-align: left;
  line-height: 1.6;
}
#controls td {
  font-weight: bold;
  cursor: pointer;
  display: block;
  margin: 0.2em 0 0.2em 2em;
  text-align: center;
  width: 6em;
  line-height: 1.6;
  background: #111;
  border-radius: 5px;
}
#controls td:hover {
  background: #191919;
}

#controls td:active {
  background: #1a1a1a;
}


/* Settings */
.left,
.right {
  font-family: FontAwesome;
  font-weight: normal;
  font-style: normal;
  cursor: pointer;
  -webkit-font-smoothing: antialiased;
  -webkit-transition:all .1s ease-out;
  transition:all .1s ease-out
}
.left:hover,
.right:hover {
  color: #4da6ee;
}
.left:before,
.right:before {
  text-decoration: inherit;
  display: inline-block;
}
.left:before  { content: "\f022"; }
.right:before { content: "\f023"; }

#settings {
  margin: 0 0 1em;
}
#settings b {
  text-align: left;
  display: inline-block;
  width: 7em;
}
#settings span {
  text-align: center;
  font-weight: bold;
  display: inline-block;
  width: 5em;
  margin: 0.3em 0;
}

/* Special Menus */
#go {
  background: none;
  transition: opacity .8s ease-out .8s;
}
#go ul {
  width: 100%;
  position: absolute;
  bottom: 2em;
}

#pause {
  background: none;
  transition: opacity .8s ease-out;
}
#pause ul {
  width: 100%;
  position: absolute;
  bottom: 2em;
}
@keyframes colorChange {
            0% { color: red; }
            25% { color: blue; }
            50% { color: rgb(58, 0, 138); }
            75% { color: orange; }
            100% { color: rgb(69, 2, 69); }
        }

.try:hover {
    /* Apply the animation on hover */
    animation: colorChange 7s linear infinite;
}
header {
            background-color: #333;
            color: #fff;
            padding: 20px 0;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px 100px;
            /* padding-bottom: 15px; */
        }
        header h1 {
            margin: 0;
            font-size: 24px;
        }
        nav ul {
            list-style: none;
            padding: 0;
        }
        nav ul li {
            display: inline;
            margin-right: 20px;
        }
        nav ul li a {
            color: #fff;
            text-decoration: none;
            font-size: 20px;
        }
  </style>
<!--<canvas id=bg></canvas>-->
<video id=bg src=bg.webm loop autoplay></video>
<div id=content>
  <header style="font-family: 'Gill Sans', 'Gill Sans MT', Calibri, 'Trebuchet MS', sans-serif;">
    <h1>GameZone</h1>
    <nav>
        <ul>
            <li><a href="/Gamelogout5">Game Logout</a></li>
        </ul>
    </nav>
  </header>

  <!-- Canvases -->
  <div id=d>
    <h3>Hold</h3>

    <div id=a>
      <canvas id=hold></canvas>
    </div>
    <ul id=replay style=display:none>
      <li><a onclick=replay(-1)>prev</a>
      <li><a onclick=replay()>Play/Pause</a>
      <li><a onclick=replay(1)>next</a>
    </ul>

    <table id=stats>
      <tr><td id=line>0<th>Line
      <tr><td id=piece>0<th>Piece
      <tr><th id=time>00:00.00
    </table>
  </div>

  <div id=b>
    <canvas id=bgStack></canvas>
    <canvas id=stack></canvas>
    <canvas id=active></canvas>

    <p id=msg>

    <nav class='menu on'>
      <h1 class="try">Tetris</h1>
      <ul>
        <li><a onclick=init(0)>Play Sprint</a>
        <!--<li><a onclick=init(1)>Play Marathon</a>
        <li><a onclick=init(2)>Play Ultra</a>-->
        <li><a onclick=init(3)>Play Dig Race</a>
        <li><a onclick=menu(2)><i class=></i>Controls</a>
        <li><a onclick=menu(1)><i class=icon-cog></i>Settings</a>
      </ul>
    </nav>

    <div class=menu>
      <h2>Settings</h2>
      <div id=settings>
      </div>
      <div style=clear:both><a class=button onclick=menu(0)>Done</a></div>
    </div>

    <div class=menu>
      <h2>Controls</h2>
      <p>Click on the control you want to change, then press any key.
      <table id=controls>
        <tr> <th>Move Left:    <td id=moveLeft>←
        <tr> <th>Move Right:   <td id=moveRight>→
        <tr> <th>Move Down:    <td id=moveDown>↓
        <tr> <th>Hard Drop:    <td id=hardDrop>Space
        <tr> <th>Hold:         <td id=holdPiece>C
        <tr> <th>Spin Right:   <td id=rotRight>X
        <tr> <th>Spin Left:    <td id=rotLeft>Z
        <tr> <th>Spin 180:     <td id=rot180>Shift
        <tr> <th>Retry:        <td id=retry>R
        <tr> <th>Pause:        <td id=pause>Esc
      </table>
      <div style=clear:both><a class=button onclick=menu(0)>Done</a></div>
    </div>

    <nav id=go class=menu>
      <ul>
        <li><a onclick=init(gametype)>Retry</a>
        <li><a onclick=init(replay)>Watch Replay</a>
        <li><a onclick=menu(0)>Main Menu</a>
      </ul>
    </nav>

    <nav id=pause class=menu>
      <ul>
        <li><a onclick=unpause()>Return</a>
        <li><a onclick=init(gametype)>Retry</a>
        <li><a onclick=menu(0)>Main Menu</a>
      </ul>
    </nav>
  </div>

  <div id=c>
    <h3>Next</h3>
    <canvas id=preview></canvas>
  </div>

</div>

<canvas id=sprite></canvas>
<!-- <script src=tetris.js></script> -->
<script>
    /*
Author: Simon Laroche
Site: http://simon.lc/
Demo: http://simon.lc/tetr.js

Note: Before looking at this code, it would be wise to do a bit of reading about
the game so you know why some things are done a certain way.
*/
'use strict';

/**
 * Playfield.
 */
var cellSize;
var column;

/**
 * Get html elements.
 */
var msg = document.getElementById('msg');
var stats = document.getElementById('stats');
var statsTime = document.getElementById('time');
var statsLines = document.getElementById('line');
var statsPiece = document.getElementById('piece');
var h3 = document.getElementsByTagName('h3');
var set = document.getElementById('settings');

// Get canvases and contexts
var holdCanvas = document.getElementById('hold');
var bgStackCanvas = document.getElementById('bgStack');
var stackCanvas = document.getElementById('stack');
var activeCanvas = document.getElementById('active');
var previewCanvas = document.getElementById('preview');
var spriteCanvas = document.getElementById('sprite');

var holdCtx = holdCanvas.getContext('2d');
var bgStackCtx = bgStackCanvas.getContext('2d');
var stackCtx = stackCanvas.getContext('2d');
var activeCtx = activeCanvas.getContext('2d');
var previewCtx = previewCanvas.getContext('2d');
var spriteCtx = spriteCanvas.getContext('2d');

/**
 * Piece data
 */

// NOTE y values are inverted since our matrix counts from top to bottom.
var kickData = [
  [[0, 0], [0, 0], [0, 0], [0, 0], [0, 0]],
  [[0, 0], [1, 0], [1, 1], [0, -2], [1, -2]],
  [[0, 0], [0, 0], [0, 0], [0, 0], [0, 0]],
  [[0, 0], [-1, 0], [-1, 1], [0, -2], [-1, -2]],
];
var kickDataI = [
  [[0, 0], [-1, 0], [2, 0], [-1, 0], [2, 0]],
  [[-1, 0], [0, 0], [0, 0], [0, -1], [0, 2]],
  [[-1, -1], [1, -1], [-2, -1], [1, 0], [-2, 0]],
  [[0, -1], [0, -1], [0, -1], [0, 1], [0, -2]],
];
// TODO get rid of this lol.
var kickDataO = [[[0, 0]], [[0, 0]], [[0, 0]], [[0, 0]]];

// Define shapes and spawns.
var PieceI = {
  index: 0,
  x: 2,
  y: -1,
  kickData: kickDataI,
  tetro: [
    [0, 0, 0, 0, 0],
    [0, 0, 1, 0, 0],
    [0, 0, 1, 0, 0],
    [0, 0, 1, 0, 0],
    [0, 0, 1, 0, 0],
  ],
};
var PieceJ = {
  index: 1,
  x: 3,
  y: 0,
  kickData: kickData,
  tetro: [[2, 2, 0], [0, 2, 0], [0, 2, 0]],
};
var PieceL = {
  index: 2,
  x: 3,
  y: 0,
  kickData: kickData,
  tetro: [[0, 3, 0], [0, 3, 0], [3, 3, 0]],
};
var PieceO = {
  index: 3,
  x: 4,
  y: 0,
  kickData: kickDataO,
  tetro: [[4, 4], [4, 4]],
};
var PieceS = {
  index: 4,
  x: 3,
  y: 0,
  kickData: kickData,
  tetro: [[0, 5, 0], [5, 5, 0], [5, 0, 0]],
};
var PieceT = {
  index: 5,
  x: 3,
  y: 0,
  kickData: kickData,
  tetro: [[0, 6, 0], [6, 6, 0], [0, 6, 0]],
};
var PieceZ = {
  index: 6,
  x: 3,
  y: 0,
  kickData: kickData,
  tetro: [[7, 0, 0], [7, 7, 0], [0, 7, 0]],
};
var pieces = [PieceI, PieceJ, PieceL, PieceO, PieceS, PieceT, PieceZ];

// Finesse data
// index x orientatio x column = finesse
// finesse[0][0][4] = 1
// TODO double check these.
var finesse = [
  [
    [1, 2, 1, 0, 1, 2, 1],
    [2, 2, 2, 2, 1, 1, 2, 2, 2, 2],
    [1, 2, 1, 0, 1, 2, 1],
    [2, 2, 2, 2, 1, 1, 2, 2, 2, 2],
  ],
  [
    [1, 2, 1, 0, 1, 2, 2, 1],
    [2, 2, 3, 2, 1, 2, 3, 3, 2],
    [2, 3, 2, 1, 2, 3, 3, 2],
    [2, 3, 2, 1, 2, 3, 3, 2, 2],
  ],
  [
    [1, 2, 1, 0, 1, 2, 2, 1],
    [2, 2, 3, 2, 1, 2, 3, 3, 2],
    [2, 3, 2, 1, 2, 3, 3, 2],
    [2, 3, 2, 1, 2, 3, 3, 2, 2],
  ],
  [
    [1, 2, 2, 1, 0, 1, 2, 2, 1],
    [1, 2, 2, 1, 0, 1, 2, 2, 1],
    [1, 2, 2, 1, 0, 1, 2, 2, 1],
    [1, 2, 2, 1, 0, 1, 2, 2, 1],
  ],
  [
    [1, 2, 1, 0, 1, 2, 2, 1],
    [2, 2, 2, 1, 1, 2, 3, 2, 2],
    [1, 2, 1, 0, 1, 2, 2, 1],
    [2, 2, 2, 1, 1, 2, 3, 2, 2],
  ],
  [
    [1, 2, 1, 0, 1, 2, 2, 1],
    [2, 2, 3, 2, 1, 2, 3, 3, 2],
    [2, 3, 2, 1, 2, 3, 3, 2],
    [2, 3, 2, 1, 2, 3, 3, 2, 2],
  ],
  [
    [1, 2, 1, 0, 1, 2, 2, 1],
    [2, 2, 2, 1, 1, 2, 3, 2, 2],
    [1, 2, 1, 0, 1, 2, 2, 1],
    [2, 2, 2, 1, 1, 2, 3, 2, 2],
  ],
];

/**
 * Gameplay specific vars.
 */
var gravityUnit = 0.00390625;
var gravity;
var gravityArr = (function() {
  var array = [];
  array.push(0);
  for (var i = 1; i < 64; i++) array.push(i / 64);
  for (var i = 1; i <= 20; i++) array.push(i);
  return array;
})();

var settings = {
  DAS: 10,
  ARR: 1,
  Gravity: 0,
  'Soft Drop': 31,
  'Lock Delay': 30,
  Size: 0,
  Sound: 0,
  Volume: 100,
  Block: 0,
  Ghost: 0,
  Grid: 0,
  Outline: 0,
};

var setting = {
  DAS: range(0, 31),
  ARR: range(0, 11),
  Gravity: (function() {
    var array = [];
    array.push('Auto');
    array.push('0G');
    for (var i = 1; i < 64; i++) array.push(i + '/64G');
    for (var i = 1; i <= 20; i++) array.push(i + 'G');
    return array;
  })(),
  'Soft Drop': (function() {
    var array = [];
    for (var i = 1; i < 64; i++) array.push(i + '/64G');
    for (var i = 1; i <= 20; i++) array.push(i + 'G');
    return array;
  })(),
  'Lock Delay': range(0, 101),
  Size: ['Auto', 'Small', 'Medium', 'Large'],
  Sound: ['Off', 'On'],
  Volume: range(0, 101),
  Block: ['Shaded', 'Solid', 'Glossy', 'Arika', 'World'],
  Ghost: ['Normal', 'Colored', 'Off'],
  Grid: ['Off', 'On'],
  Outline: ['Off', 'On'],
};

var frame;

/**
 *Pausing variables
 */

var startPauseTime;
var pauseTime;

/**
 * 0 = Normal
 * 1 = win
 * 2 = countdown
 * 3 = game not played
 * 9 = loss
 */
var gameState = 3;

var paused = false;
var lineLimit;

var replayKeys;
var watchingReplay = false;
var toGreyRow;
var gametype;
//TODO Make dirty flags for each canvas, draw them all at once during frame call.
// var dirtyHold, dirtyActive, dirtyStack, dirtyPreview;
var lastX, lastY, lastPos, landed;

// Stats
var lines;
var statsFinesse;
var piecesSet;
var startTime;
var digLines;

// Keys
var keysDown;
var lastKeys;
var released;

var binds = {
  pause: 27,
  moveLeft: 37,
  moveRight: 39,
  moveDown: 40,
  hardDrop: 32,
  holdPiece: 67,
  rotRight: 88,
  rotLeft: 90,
  rot180: 16,
  retry: 82,
};
var flags = {
  hardDrop: 1,
  moveRight: 2,
  moveLeft: 4,
  moveDown: 8,
  holdPiece: 16,
  rotRight: 32,
  rotLeft: 64,
  rot180: 128,
};

function resize() {
  var a = document.getElementById('a');
  var b = document.getElementById('b');
  var c = document.getElementById('c');
  var content = document.getElementById('content');

  // TODO Finalize this.
  // Aspect ratio: 1.024
  var screenHeight = window.innerHeight - 34;
  var screenWidth = ~~(screenHeight * 1.024);
  if (screenWidth > window.innerWidth)
    screenHeight = ~~(window.innerWidth / 1.024);

  if (settings.Size === 1 && screenHeight > 602) cellSize = 15;
  else if (settings.Size === 2 && screenHeight > 602) cellSize = 30;
  else if (settings.Size === 3 && screenHeight > 902) cellSize = 45;
  else cellSize = Math.max(~~(screenHeight / 20), 10);

  var pad = (window.innerHeight - (cellSize * 20 + 2)) / 2 + 'px';
  content.style.padding = pad + ' 0';
  stats.style.bottom = pad;

  // Size elements
  a.style.padding = '0 0.5rem ' + ~~(cellSize / 2) + 'px';

  stackCanvas.width = activeCanvas.width = bgStackCanvas.width = cellSize * 10;
  stackCanvas.height = activeCanvas.height = bgStackCanvas.height =
    cellSize * 20;
  b.style.width = stackCanvas.width + 'px';
  b.style.height = stackCanvas.height + 'px';

  holdCanvas.width = cellSize * 4;
  holdCanvas.height = cellSize * 2;
  a.style.width = holdCanvas.width + 'px';
  a.style.height = holdCanvas.height + 'px';

  previewCanvas.width = cellSize * 4;
  previewCanvas.height = stackCanvas.height;
  c.style.width = previewCanvas.width + 'px';
  c.style.height = b.style.height;

  // Scale the text so it fits in the thing.
  // TODO get rid of extra font sizes here.
  msg.style.lineHeight = b.style.height;
  msg.style.fontSize = ~~(stackCanvas.width / 6) + 'px';
  stats.style.fontSize = ~~(stackCanvas.width / 11) + 'px';
  document.documentElement.style.fontSize = ~~(stackCanvas.width / 16) + 'px';

  stats.style.width = a.style.width;
  for (var i = 0, len = h3.length; i < len; i++) {
    h3[i].style.lineHeight = a.style.height;
    h3[i].style.fontSize = stats.style.fontSize;
  }

  // Redraw graphics
  makeSprite();

  if (settings.Grid === 1) bg(bgStackCtx);

  if (gameState === 0) {
    piece.drawGhost();
    piece.draw();
    stack.draw();
    preview.draw();
    if (hold.piece) {
      hold.draw();
    }
  }
}
addEventListener('resize', resize, false);

/**
 * ========================== Model ===========================================
 */

/**
 * Resets all the settings and starts the game.
 */
function init(gt) {
  if (gt === 'replay') {
    watchingReplay = true;
  } else {
    watchingReplay = false;
    replayKeys = {};
    // TODO Make new seed and rng method.
    replayKeys.seed = ~~(Math.random() * 2147483645) + 1;
    gametype = gt;
  }

  lineLimit = 40;

  //Reset
  column = 0;
  keysDown = 0;
  lastKeys = 0;
  released = 255;
  //TODO Check if needed.
  piece.shiftDir = 0;
  piece.shiftReleased = true;

  startPauseTime = 0;
  pauseTime = 0;
  paused = false;

  rng.seed = replayKeys.seed;
  toGreyRow = 21;
  frame = 0;
  lastPos = 'reset';
  stack.new(10, 22);
  hold.piece = void 0;
  if (settings.Gravity === 0) gravity = gravityUnit * 4;
  startTime = Date.now();

  preview.init();
  //preview.draw();

  statsFinesse = 0;
  lines = 0;
  piecesSet = 0;

  statsPiece.innerHTML = piecesSet;
  statsLines.innerHTML = lineLimit - lines;
  statistics();
  clear(stackCtx);
  clear(activeCtx);
  clear(holdCtx);

  if (gametype === 3) {
    // Dig Race
    // make ten random numbers, make sure next isn't the same as last?
    //TODO make into function or own file.

    digLines = [12, 13, 14, 15, 16, 17, 18, 19, 20, 21];

    statsLines.innerHTML = 10;
    statsLines.innerHTML = 10;
    var randomNums = [];
    for (var i = 0; i < 10; i++) {
      var random = ~~(rng.next() * 10);
      if (random !== randomNums[i - 1]) randomNums.push(random);
      else i--;
    }
    for (var y = 21; y > 11; y--) {
      for (var x = 0; x < 10; x++) {
        if (randomNums[y - 12] !== x) stack.grid[x][y] = 8;
      }
    }
    stack.draw();
  }

  menu();

  // Only start a loop if one is not running already.
  if (gameState === 3) {
    gameState = 2;
    gameLoop();
  } else {
    gameState = 2;
  }
}

function range(start, end, inc) {
  inc = inc || 1;
  var array = [];
  for (var i = start; i < end; i += inc) {
    array.push(i);
  }
  return array;
}

/**
 * Add divisor method so we can do clock arithmetics. This is later used to
 *  determine tetromino orientation.
 */
Number.prototype.mod = function(n) {
  return ((this % n) + n) % n;
};

/**
 * Shim.
 */
window.requestAnimFrame = (function() {
  return (
    window.requestAnimationFrame ||
    window.mozRequestAnimationFrame ||
    window.webkitRequestAnimationFrame ||
    function(callback) {
      window.setTimeout(callback, 1000 / 60);
    }
  );
})();

function pause() {
  if (gameState === 0) {
    paused = true;
    startPauseTime = Date.now();
    msg.innerHTML = 'Paused';
    menu(4);
  }
}

function unpause() {
  paused = false;
  pauseTime += Date.now() - startPauseTime;
  msg.innerHTML = '';
  menu();
}

/**
 * Park Miller "Minimal Standard" PRNG.
 */
//TODO put random seed method in here.
var rng = new function() {
  this.seed = 1;
  this.next = function() {
    // Returns a float between 0.0, and 1.0
    return this.gen() / 2147483647;
  };
  this.gen = function() {
    return (this.seed = (this.seed * 16807) % 2147483647);
  };
}();

/**
 * Draws the stats next to the tetrion.
 */
function statistics() {
  var time = Date.now() - startTime - pauseTime;
  var seconds = ((time / 1000) % 60).toFixed(2);
  var minutes = ~~(time / 60000);
  statsTime.innerHTML =
    (minutes < 10 ? '0' : '') + minutes + (seconds < 10 ? ':0' : ':') + seconds;
}

// ========================== View ============================================

/**
 * Draws grid in background.
 */
function bg(ctx) {
  ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
  ctx.fillStyle = '#1c1c1c';
  for (var x = -1; x < ctx.canvas.width + 1; x += cellSize) {
    ctx.fillRect(x, 0, 2, ctx.canvas.height);
  }
  for (var y = -1; y < ctx.canvas.height + 1; y += cellSize) {
    ctx.fillRect(0, y, ctx.canvas.width, 2);
  }
}

/**
 * Draws a pre-rendered mino.
 */
function drawCell(x, y, color, ctx) {
  x = x * cellSize;
  x = ~~x;
  y = ~~y * cellSize - 2 * cellSize;
  ctx.drawImage(
    spriteCanvas,
    color * cellSize,
    0,
    cellSize,
    cellSize,
    x,
    y,
    cellSize,
    cellSize,
  );
}

/**
 * Pre-renders all mino types in all colors.
 */
function makeSprite() {
  var shaded = [
    // 0         +10        -10        -20
    ['#c1c1c1', '#dddddd', '#a6a6a6', '#8b8b8b'],
    ['#25bb9b', '#4cd7b6', '#009f81', '#008568'],
    ['#3397d9', '#57b1f6', '#007dbd', '#0064a2'],
    ['#e67e23', '#ff993f', '#c86400', '#a94b00'],
    ['#efc30f', '#ffdf3a', '#d1a800', '#b38e00'],
    ['#9ccd38', '#b9e955', '#81b214', '#659700'],
    ['#9c5ab8', '#b873d4', '#81409d', '#672782'],
    ['#e64b3c', '#ff6853', '#c62c25', '#a70010'],
    ['#898989', '#a3a3a3', '#6f6f6f', '#575757'],
  ];
  var glossy = [
    //25         37         52         -21        -45
    ['#ffffff', '#ffffff', '#ffffff', '#888888', '#4d4d4d'],
    ['#7bffdf', '#9fffff', '#ccffff', '#008165', '#00442e'],
    ['#6cdcff', '#93feff', '#c2ffff', '#00629f', '#002c60'],
    ['#ffc166', '#ffe386', '#ffffb0', '#aa4800', '#650500'],
    ['#ffff6a', '#ffff8c', '#ffffb8', '#b68a00', '#714f00'],
    ['#efff81', '#ffffa2', '#ffffcd', '#6b9200', '#2c5600'],
    ['#dc9dfe', '#ffbeff', '#ffe9ff', '#5d287e', '#210043'],
    ['#ff9277', '#ffb497', '#ffe0bf', '#a7000a', '#600000'],
    ['#cbcbcb', '#ededed', '#ffffff', '#545454', '#1f1f1f'],
  ];
  var tgm = [
    ['#7b7b7b', '#303030', '#6b6b6b', '#363636'],
    ['#f08000', '#a00000', '#e86008', '#b00000'],
    ['#00a8f8', '#0000b0', '#0090e8', '#0020c0'],
    ['#f8a800', '#b84000', '#e89800', '#c85800'],
    ['#e8e000', '#886800', '#d8c800', '#907800'],
    ['#f828f8', '#780078', '#e020e0', '#880088'],
    ['#00e8f0', '#0070a0', '#00d0e0', '#0080a8'],
    ['#78f800', '#007800', '#58e000', '#008800'],
    ['#7b7b7b', '#303030', '#6b6b6b', '#363636'],
  ];
  var world = [];
  world[0] = tgm[0];
  world[1] = tgm[6];
  world[2] = tgm[2];
  world[3] = tgm[3];
  world[4] = tgm[4];
  world[5] = tgm[7];
  world[6] = tgm[5];
  world[7] = tgm[1];
  world[8] = tgm[8];

  spriteCanvas.width = cellSize * 9;
  spriteCanvas.height = cellSize;
  for (var i = 0; i < 9; i++) {
    var x = i * cellSize;
    if (settings.Block === 0) {
      // Shaded
      spriteCtx.fillStyle = shaded[i][1];
      spriteCtx.fillRect(x, 0, cellSize, cellSize);

      spriteCtx.fillStyle = shaded[i][3];
      spriteCtx.fillRect(x, cellSize / 2, cellSize, cellSize / 2);

      spriteCtx.fillStyle = shaded[i][0];
      spriteCtx.beginPath();
      spriteCtx.moveTo(x, 0);
      spriteCtx.lineTo(x + cellSize / 2, cellSize / 2);
      spriteCtx.lineTo(x, cellSize);
      spriteCtx.fill();

      spriteCtx.fillStyle = shaded[i][2];
      spriteCtx.beginPath();
      spriteCtx.moveTo(x + cellSize, 0);
      spriteCtx.lineTo(x + cellSize / 2, cellSize / 2);
      spriteCtx.lineTo(x + cellSize, cellSize);
      spriteCtx.fill();
    } else if (settings.Block === 1) {
      // Flat
      spriteCtx.fillStyle = shaded[i][0];
      spriteCtx.fillRect(x, 0, cellSize, cellSize);
    } else if (settings.Block === 2) {
      // Glossy
      var k = Math.max(~~(cellSize * 0.083), 1);

      var grad = spriteCtx.createLinearGradient(x, 0, x + cellSize, cellSize);
      grad.addColorStop(0.5, glossy[i][3]);
      grad.addColorStop(1, glossy[i][4]);
      spriteCtx.fillStyle = grad;
      spriteCtx.fillRect(x, 0, cellSize, cellSize);

      var grad = spriteCtx.createLinearGradient(x, 0, x + cellSize, cellSize);
      grad.addColorStop(0, glossy[i][2]);
      grad.addColorStop(0.5, glossy[i][1]);
      spriteCtx.fillStyle = grad;
      spriteCtx.fillRect(x, 0, cellSize - k, cellSize - k);

      var grad = spriteCtx.createLinearGradient(
        x + k,
        k,
        x + cellSize - k,
        cellSize - k,
      );
      grad.addColorStop(0, shaded[i][0]);
      grad.addColorStop(0.5, glossy[i][0]);
      grad.addColorStop(0.5, shaded[i][0]);
      grad.addColorStop(1, glossy[i][0]);
      spriteCtx.fillStyle = grad;
      spriteCtx.fillRect(x + k, k, cellSize - k * 2, cellSize - k * 2);
    } else if (settings.Block === 3 || settings.Block === 4) {
      // Arika
      if (settings.Block === 4) tgm = world;
      var k = Math.max(~~(cellSize * 0.125), 1);

      spriteCtx.fillStyle = tgm[i][1];
      spriteCtx.fillRect(x, 0, cellSize, cellSize);
      spriteCtx.fillStyle = tgm[i][0];
      spriteCtx.fillRect(x, 0, cellSize, ~~(cellSize / 2));

      var grad = spriteCtx.createLinearGradient(x, k, x, cellSize - k);
      grad.addColorStop(0, tgm[i][2]);
      grad.addColorStop(1, tgm[i][3]);
      spriteCtx.fillStyle = grad;
      spriteCtx.fillRect(x + k, k, cellSize - k * 2, cellSize - k * 2);

      var grad = spriteCtx.createLinearGradient(x, k, x, cellSize);
      grad.addColorStop(0, tgm[i][0]);
      grad.addColorStop(1, tgm[i][3]);
      spriteCtx.fillStyle = grad;
      spriteCtx.fillRect(x, k, k, cellSize - k);

      var grad = spriteCtx.createLinearGradient(x, 0, x, cellSize - k);
      grad.addColorStop(0, tgm[i][2]);
      grad.addColorStop(1, tgm[i][1]);
      spriteCtx.fillStyle = grad;
      spriteCtx.fillRect(x + cellSize - k, 0, k, cellSize - k);
    }
  }
}

/**
 * Clear canvas.
 */
function clear(ctx) {
  ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
}

/**
 * Draws a 2d array of minos.
 */
function draw(tetro, cx, cy, ctx, color) {
  for (var x = 0, len = tetro.length; x < len; x++) {
    for (var y = 0, wid = tetro[x].length; y < wid; y++) {
      if (tetro[x][y])
        drawCell(x + cx, y + cy, color !== void 0 ? color : tetro[x][y], ctx);
    }
  }
}

// ========================== Controller ======================================

addEventListener(
  'keydown',
  function(e) {
    // TODO send to menu or game depending on context.
    if ([32, 37, 38, 39, 40].indexOf(e.keyCode) !== -1) e.preventDefault();
    //TODO if active, prevent default for binded keys
    //if (bindsArr.indexOf(e.keyCode) !== -1)
    //  e.preventDefault();
    if (e.keyCode === binds.pause) {
      if (paused) {
        unpause();
      } else {
        pause();
      }
    }
    if (e.keyCode === binds.retry) {
      init(gametype);
    }
    if (!watchingReplay) {
      if (e.keyCode === binds.moveLeft) {
        keysDown |= flags.moveLeft;
        //piece.finesse++
      } else if (e.keyCode === binds.moveRight) {
        keysDown |= flags.moveRight;
      } else if (e.keyCode === binds.moveDown) {
        keysDown |= flags.moveDown;
      } else if (e.keyCode === binds.hardDrop) {
        keysDown |= flags.hardDrop;
      } else if (e.keyCode === binds.rotRight) {
        keysDown |= flags.rotRight;
      } else if (e.keyCode === binds.rotLeft) {
        keysDown |= flags.rotLeft;
      } else if (e.keyCode === binds.rot180) {
        keysDown |= flags.rot180;
      } else if (e.keyCode === binds.holdPiece) {
        keysDown |= flags.holdPiece;
      }
    }
  },
  false,
);
addEventListener(
  'keyup',
  function(e) {
    if (!watchingReplay) {
      if (e.keyCode === binds.moveLeft && keysDown & flags.moveLeft) {
        keysDown ^= flags.moveLeft;
      } else if (e.keyCode === binds.moveRight && keysDown & flags.moveRight) {
        keysDown ^= flags.moveRight;
      } else if (e.keyCode === binds.moveDown && keysDown & flags.moveDown) {
        keysDown ^= flags.moveDown;
      } else if (e.keyCode === binds.hardDrop && keysDown & flags.hardDrop) {
        keysDown ^= flags.hardDrop;
      } else if (e.keyCode === binds.rotRight && keysDown & flags.rotRight) {
        keysDown ^= flags.rotRight;
      } else if (e.keyCode === binds.rotLeft && keysDown & flags.rotLeft) {
        keysDown ^= flags.rotLeft;
      } else if (e.keyCode === binds.rot180 && keysDown & flags.rot180) {
        keysDown ^= flags.rot180;
      } else if (e.keyCode === binds.holdPiece && keysDown & flags.holdPiece) {
        keysDown ^= flags.holdPiece;
      }
    }
  },
  false,
);

// ========================== Loop ============================================

//TODO Cleanup gameloop and update.
/**
 * Runs every frame.
 */
function update() {
  //TODO Das preservation broken.
  if (lastKeys !== keysDown && !watchingReplay) {
    replayKeys[frame] = keysDown;
  } else if (frame in replayKeys) {
    keysDown = replayKeys[frame];
  }

  if (!(lastKeys & flags.holdPiece) && flags.holdPiece & keysDown) {
    piece.hold();
  }

  if (flags.rotLeft & keysDown && !(lastKeys & flags.rotLeft)) {
    piece.rotate(-1);
    piece.finesse++;
  } else if (flags.rotRight & keysDown && !(lastKeys & flags.rotRight)) {
    piece.rotate(1);
    piece.finesse++;
  } else if (flags.rot180 & keysDown && !(lastKeys & flags.rot180)) {
    piece.rotate(1);
    piece.rotate(1);
    piece.finesse++;
  }

  piece.checkShift();

  if (flags.moveDown & keysDown) {
    piece.shiftDown();
    //piece.finesse++;
  }
  if (!(lastKeys & flags.hardDrop) && flags.hardDrop & keysDown) {
    piece.hardDrop();
  }

  piece.update();

  // Win
  // TODO
  if (gametype !== 3) {
    if (lines >= lineLimit) {
      gameState = 1;
      msg.innerHTML = 'GREAT!';
      menu(3);
    }
  } else {
    if (digLines.length === 0) {
      gameState = 1;
      msg.innerHTML = 'GREAT!';
      menu(3);
    }
  }

  statistics();

  if (lastKeys !== keysDown) {
    lastKeys = keysDown;
  }
}

function gameLoop() {
  requestAnimFrame(gameLoop);

  //TODO check to see how pause works in replays.
  frame++;

  if (gameState === 0) {
    // Playing

    if (!paused) {
      update();
    }

    // TODO improve this with 'dirty' flags.
    if (
      piece.x !== lastX ||
      Math.floor(piece.y) !== lastY ||
      piece.pos !== lastPos ||
      piece.dirty
    ) {
      clear(activeCtx);
      piece.drawGhost();
      piece.draw();
    }
    lastX = piece.x;
    lastY = Math.floor(piece.y);
    lastPos = piece.pos;
    piece.dirty = false;
  } else if (gameState === 2) {
    // Count Down
    if (frame < 50) {
      if (msg.innerHTML !== 'READY') msg.innerHTML = 'READY';
    } else if (frame < 100) {
      if (msg.innerHTML !== 'GO!') msg.innerHTML = 'GO!';
    } else {
      msg.innerHTML = '';
      gameState = 0;
      startTime = Date.now();
      piece.new(preview.next());
    }
    // DAS Preload
    if (lastKeys !== keysDown && !watchingReplay) {
      replayKeys[frame] = keysDown;
    } else if (frame in replayKeys) {
      keysDown = replayKeys[frame];
    }
    if (keysDown & flags.moveLeft) {
      lastKeys = keysDown;
      piece.shiftDelay = settings.DAS;
      piece.shiftReleased = false;
      piece.shiftDir = -1;
    } else if (keysDown & flags.moveRight) {
      lastKeys = keysDown;
      piece.shiftDelay = settings.DAS;
      piece.shiftReleased = false;
      piece.shiftDir = 1;
    }
  } else if (toGreyRow >= 2) {
    /**
     * Fade to grey animation played when player loses.
     */
    if (toGreyRow === 21) clear(activeCtx);
    if (frame % 2) {
      for (var x = 0; x < 10; x++) {
        if (stack.grid[x][toGreyRow]) stack.grid[x][toGreyRow] = gameState - 1;
      }
      stack.draw();
      toGreyRow--;
    }
  }
}
</script>
<!-- <script src=piece.js></script> -->
<script>
    function Piece() {
  this.x;
  this.y;
  this.pos = 0;
  this.tetro;
  this.index;
  this.kickData;
  this.lockDelay = 0;
  this.shiftDelay = 0;
  this.shiftDir;
  this.shiftReleased;
  this.arrDelay = 0;
  this.held = false;
  this.finesse = 0;
  this.dirty = false;
}
/**
 * Removes last active piece, and gets the next active piece from the grab bag.
 */
Piece.prototype.new = function(index) {
  // TODO if no arguments, get next grabbag piece
  this.pos = 0;
  this.tetro = [];
  this.held = false;
  this.finesse = 0;
  this.dirty = true;
  //TODO change this
  landed = false;

  // TODO Do this better. Make clone object func maybe.
  //for property in pieces, this.prop = piece.prop
  this.tetro = pieces[index].tetro;
  this.kickData = pieces[index].kickData;
  this.x = pieces[index].x;
  this.y = pieces[index].y;
  this.index = index;

  // TODO ---------------- snip

  //TODO Do this better. (make grabbag object)
  // Preview.next(); == grabbag.next()
  // Preview.draw();
  //preview.next();

  // Check for blockout.
  if (!this.moveValid(0, 0, this.tetro)) {
    gameState = 9;
    msg.innerHTML = 'BLOCK OUT!';
    menu(3);
  }
};
Piece.prototype.rotate = function(direction) {
  // Rotates tetromino.
  var rotated = [];
  if (direction === -1) {
    for (var i = this.tetro.length - 1; i >= 0; i--) {
      rotated[i] = [];
      for (var row = 0; row < this.tetro.length; row++) {
        rotated[i][this.tetro.length - 1 - row] = this.tetro[row][i];
      }
    }
  } else {
    for (var i = 0; i < this.tetro.length; i++) {
      rotated[i] = [];
      for (var row = this.tetro.length - 1; row >= 0; row--) {
        rotated[i][row] = this.tetro[row][this.tetro.length - 1 - i];
      }
    }
  }

  // Goes thorugh kick data until it finds a valid move.
  var curPos = this.pos.mod(4);
  var newPos = (this.pos + direction).mod(4);

  for (var x = 0, len = this.kickData[0].length; x < len; x++) {
    if (
      this.moveValid(
        this.kickData[curPos][x][0] - this.kickData[newPos][x][0],
        this.kickData[curPos][x][1] - this.kickData[newPos][x][1],
        rotated,
      )
    ) {
      this.x += this.kickData[curPos][x][0] - this.kickData[newPos][x][0];
      this.y += this.kickData[curPos][x][1] - this.kickData[newPos][x][1];
      this.tetro = rotated;
      this.pos = newPos;
      // TODO make 180 rotate count as one or just update finess 180s
      //this.finesse++;
      break;
    }
  }
};
Piece.prototype.checkShift = function() {
  // Shift key pressed event.
  if (keysDown & flags.moveLeft && !(lastKeys & flags.moveLeft)) {
    this.shiftDelay = 0;
    this.arrDelay = 0;
    this.shiftReleased = true;
    this.shiftDir = -1;
    this.finesse++;
  } else if (keysDown & flags.moveRight && !(lastKeys & flags.moveRight)) {
    this.shiftDelay = 0;
    this.arrDelay = 0;
    this.shiftReleased = true;
    this.shiftDir = 1;
    this.finesse++;
  }
  // Shift key released event.
  if (
    this.shiftDir === 1 &&
    !(keysDown & flags.moveRight) &&
    lastKeys & flags.moveRight &&
    keysDown & flags.moveLeft
  ) {
    this.shiftDelay = 0;
    this.arrDelay = 0;
    this.shiftReleased = true;
    this.shiftDir = -1;
  } else if (
    this.shiftDir === -1 &&
    !(keysDown & flags.moveLeft) &&
    lastKeys & flags.moveLeft &&
    keysDown & flags.moveRight
  ) {
    this.shiftDelay = 0;
    this.arrDelay = 0;
    this.shiftReleased = true;
    this.shiftDir = 1;
  } else if (
    !(keysDown & flags.moveRight) &&
    lastKeys & flags.moveRight &&
    keysDown & flags.moveLeft
  ) {
    this.shiftDir = -1;
  } else if (
    !(keysDown & flags.moveLeft) &&
    lastKeys & flags.moveLeft &&
    keysDown & flags.moveRight
  ) {
    this.shiftDir = 1;
  } else if (
    (!(keysDown & flags.moveLeft) && lastKeys & flags.moveLeft) ||
    (!(keysDown & flags.moveRight) && lastKeys & flags.moveRight)
  ) {
    this.shiftDelay = 0;
    this.arrDelay = 0;
    this.shiftReleased = true;
    this.shiftDir = 0;
  }
  // Handle events
  if (this.shiftDir) {
    // 1. When key pressed instantly move over once.
    if (this.shiftReleased) {
      this.shift(this.shiftDir);
      this.shiftDelay++;
      this.shiftReleased = false;
      // 2. Apply DAS delay
    } else if (this.shiftDelay < settings.DAS) {
      this.shiftDelay++;
      // 3. Once the delay is complete, move over once.
      //     Increment delay so this doesn't run again.
    } else if (this.shiftDelay === settings.DAS && settings.DAS !== 0) {
      this.shift(this.shiftDir);
      if (settings.ARR !== 0) this.shiftDelay++;
      // 4. Apply ARR delay
    } else if (this.arrDelay < settings.ARR) {
      this.arrDelay++;
      // 5. If ARR Delay is full, move piece, and reset delay and repeat.
    } else if (this.arrDelay === settings.ARR && settings.ARR !== 0) {
      this.shift(this.shiftDir);
    }
  }
};
Piece.prototype.shift = function(direction) {
  this.arrDelay = 0;
  if (settings.ARR === 0 && this.shiftDelay === settings.DAS) {
    for (var i = 1; i < 10; i++) {
      if (!this.moveValid(i * direction, 0, this.tetro)) {
        this.x += i * direction - direction;
        break;
      }
    }
  } else if (this.moveValid(direction, 0, this.tetro)) {
    this.x += direction;
  }
};
Piece.prototype.shiftDown = function() {
  if (this.moveValid(0, 1, this.tetro)) {
    var grav = gravityArr[settings['Soft Drop'] + 1];
    if (grav > 1) this.y += this.getDrop(grav);
    else this.y += grav;
  }
};
Piece.prototype.hardDrop = function() {
  this.y += this.getDrop(20);
  this.lockDelay = settings['Lock Delay'];
};
Piece.prototype.getDrop = function(distance) {
  for (var i = 1; i <= distance; i++) {
    if (!this.moveValid(0, i, this.tetro)) return i - 1;
  }
  return i - 1;
};
Piece.prototype.hold = function() {
  var temp = hold.piece;
  if (!this.held) {
    if (hold.piece !== void 0) {
      hold.piece = this.index;
      this.new(temp);
    } else {
      hold.piece = this.index;
      this.new(preview.next());
    }
    this.held = true;
    hold.draw();
  }
};
/**
 * Checks if position and orientation passed is valid.
 *  We call it for every action instead of only once a frame in case one
 *  of the actions is still valid, we don't want to block it.
 */
Piece.prototype.moveValid = function(cx, cy, tetro) {
  cx = cx + this.x;
  cy = Math.floor(cy + this.y);

  for (var x = 0; x < tetro.length; x++) {
    for (var y = 0; y < tetro[x].length; y++) {
      if (
        tetro[x][y] &&
        (cx + x < 0 ||
          cx + x >= 10 ||
          cy + y >= 22 ||
          stack.grid[cx + x][cy + y])
      ) {
        return false;
      }
    }
  }
  this.lockDelay = 0;
  return true;
};
Piece.prototype.update = function() {
  if (this.moveValid(0, 1, this.tetro)) {
    landed = false;
    if (settings.Gravity) {
      var grav = gravityArr[settings.Gravity - 1];
      if (grav > 1) this.y += this.getDrop(grav);
      else this.y += grav;
    } else {
      this.y += gravity;
    }
  } else {
    landed = true;
    this.y = Math.floor(this.y);
    if (this.lockDelay >= settings['Lock Delay']) {
      stack.addPiece(this.tetro);
      this.new(preview.next());
    } else {
      var a = 1 / setting['Lock Delay'][settings['Lock Delay']];
      activeCtx.globalCompositeOperation = 'source-atop';
      activeCtx.fillStyle = 'rgba(0,0,0,' + a + ')';
      activeCtx.fillRect(0, 0, activeCanvas.width, activeCanvas.height);
      activeCtx.globalCompositeOperation = 'source-over';
      this.lockDelay++;
    }
  }
};
Piece.prototype.draw = function() {
  draw(this.tetro, this.x, this.y, activeCtx);
};
Piece.prototype.drawGhost = function() {
  if (!settings.Ghost && !landed) {
    draw(this.tetro, this.x, this.y + this.getDrop(22), activeCtx, 0);
  } else if (settings.Ghost === 1 && !landed) {
    activeCtx.globalAlpha = 0.3;
    draw(this.tetro, this.x, this.y + this.getDrop(22), activeCtx);
    activeCtx.globalAlpha = 1;
  }
};

var piece = new Piece();
</script>
<!-- <script src=stack.js></script> -->
<script>
    function Stack() {
  //this.grid;
}
/**
 * Creates a matrix for the playfield.
 */
Stack.prototype.new = function(x, y) {
  var cells = new Array(x);
  for (var i = 0; i < x; i++) {
    cells[i] = new Array(y);
  }
  this.grid = cells;
};
/**
 * Adds tetro to the stack, and clears lines if they fill up.
 */
Stack.prototype.addPiece = function(tetro) {
  var once = false;

  // Add the piece to the stack.
  var range = [];
  var valid = false;
  for (var x = 0; x < tetro.length; x++) {
    for (var y = 0; y < tetro[x].length; y++) {
      if (tetro[x][y]) {
        this.grid[x + piece.x][y + piece.y] = tetro[x][y];
        // Get column for finesse
        if (!once || x + piece.x < column) {
          column = x + piece.x;
          once = true;
        }
        // Check which lines get modified
        if (range.indexOf(y + piece.y) === -1) {
          range.push(y + piece.y);
          // This checks if any cell is in the play field. If there
          //  isn't any this is called a lock out and the game ends.
          if (y + piece.y > 1) valid = true;
        }
      }
    }
  }

  // Lock out
  if (!valid) {
    gameState = 9;
    msg.innerHTML = 'LOCK OUT!';
    menu(3);
    return;
  }

  // Check modified lines for full lines.
  range = range.sort(function(a, b) {
    return a - b;
  });
  for (var row = range[0], len = row + range.length; row < len; row++) {
    var count = 0;
    for (var x = 0; x < 10; x++) {
      if (this.grid[x][row]) count++;
    }
    // Clear the line. This basically just moves down the stack.
    // TODO Ponder during the day and see if there is a more elegant solution.
    if (count === 10) {
      lines++; // NOTE stats
      if (gametype === 3) {
        if (digLines.indexOf(row) !== -1) {
          digLines.splice(digLines.indexOf(row), 1);
        }
      }
      for (var y = row; y >= -1; y--) {
        for (var x = 0; x < 10; x++) {
          this.grid[x][y] = this.grid[x][y - 1];
        }
      }
    }
  }

  statsFinesse += piece.finesse - finesse[piece.index][piece.pos][column];
  piecesSet++; // NOTE Stats
  // TODO Might not need this (same for in init)
  column = 0;

  statsPiece.innerHTML = piecesSet;

  if (gametype !== 3) statsLines.innerHTML = lineLimit - lines;
  else statsLines.innerHTML = digLines.length;

  this.draw();
};
/**
 * Draws the stack.
 */
Stack.prototype.draw = function() {
  clear(stackCtx);
  draw(this.grid, 0, 0, stackCtx);

  // Darken Stack
  // TODO wrap this with an option.
  stackCtx.globalCompositeOperation = 'source-atop';
  stackCtx.fillStyle = 'rgba(0,0,0,0.3)';
  stackCtx.fillRect(0, 0, stackCanvas.width, stackCanvas.height);
  stackCtx.globalCompositeOperation = 'source-over';

  if (settings.Outline) {
    var b = ~~(cellSize / 8);
    var c = cellSize;
    var lineCanvas = document.createElement('canvas');
    lineCanvas.width = stackCanvas.width;
    lineCanvas.height = stackCanvas.height;
    var lineCtx = lineCanvas.getContext('2d');
    lineCtx.fillStyle = 'rgba(255,255,255,0.5)';
    lineCtx.beginPath();
    for (var x = 0, len = this.grid.length; x < len; x++) {
      for (var y = 0, wid = this.grid[x].length; y < wid; y++) {
        if (this.grid[x][y]) {
          if (x < 9 && !this.grid[x + 1][y]) {
            lineCtx.fillRect(x * c + c - b, y * c - 2 * c, b, c);
          }
          if (x > 0 && !this.grid[x - 1][y]) {
            lineCtx.fillRect(x * c, y * c - 2 * c, b, c);
          }
          if (y < 21 && !this.grid[x][y + 1]) {
            lineCtx.fillRect(x * c, y * c - 2 * c + c - b, c, b);
          }
          if (!this.grid[x][y - 1]) {
            lineCtx.fillRect(x * c, y * c - 2 * c, c, b);
          }
          // Diags
          if (x < 9 && y < 21) {
            if (!this.grid[x + 1][y] && !this.grid[x][y + 1]) {
              lineCtx.clearRect(x * c + c - b, y * c - 2 * c + c - b, b, b);
              lineCtx.fillRect(x * c + c - b, y * c - 2 * c + c - b, b, b);
            } else if (
              !this.grid[x + 1][y + 1] &&
              this.grid[x + 1][y] &&
              this.grid[x][y + 1]
            ) {
              lineCtx.moveTo(x * c + c, y * c - 2 * c + c - b);
              lineCtx.lineTo(x * c + c, y * c - 2 * c + c);
              lineCtx.lineTo(x * c + c - b, y * c - 2 * c + c);
              lineCtx.arc(
                x * c + c,
                y * c - 2 * c + c,
                b,
                (3 * Math.PI) / 2,
                Math.PI,
                true,
              );
            }
          }
          if (x < 9) {
            if (!this.grid[x + 1][y] && !this.grid[x][y - 1]) {
              lineCtx.clearRect(x * c + c - b, y * c - 2 * c, b, b);
              lineCtx.fillRect(x * c + c - b, y * c - 2 * c, b, b);
            } else if (
              !this.grid[x + 1][y - 1] &&
              this.grid[x + 1][y] &&
              this.grid[x][y - 1]
            ) {
              lineCtx.moveTo(x * c + c - b, y * c - 2 * c);
              lineCtx.lineTo(x * c + c, y * c - 2 * c);
              lineCtx.lineTo(x * c + c, y * c - 2 * c + b);
              lineCtx.arc(
                x * c + c,
                y * c - 2 * c,
                b,
                Math.PI / 2,
                Math.PI,
                false,
              );
            }
          }
          if (x > 0 && y < 21) {
            if (!this.grid[x - 1][y] && !this.grid[x][y + 1]) {
              lineCtx.clearRect(x * c, y * c - 2 * c + c - b, b, b);
              lineCtx.fillRect(x * c, y * c - 2 * c + c - b, b, b);
            } else if (
              !this.grid[x - 1][y + 1] &&
              this.grid[x - 1][y] &&
              this.grid[x][y + 1]
            ) {
              lineCtx.moveTo(x * c, y * c - 2 * c + c - b);
              lineCtx.lineTo(x * c, y * c - 2 * c + c);
              lineCtx.lineTo(x * c + b, y * c - 2 * c + c);
              lineCtx.arc(
                x * c,
                y * c - 2 * c + c,
                b,
                Math.PI * 2,
                (3 * Math.PI) / 2,
                true,
              );
            }
          }
          if (x > 0) {
            if (!this.grid[x - 1][y] && !this.grid[x][y - 1]) {
              lineCtx.clearRect(x * c, y * c - 2 * c, b, b);
              lineCtx.fillRect(x * c, y * c - 2 * c, b, b);
            } else if (
              !this.grid[x - 1][y - 1] &&
              this.grid[x - 1][y] &&
              this.grid[x][y - 1]
            ) {
              lineCtx.moveTo(x * c + b, y * c - 2 * c);
              lineCtx.lineTo(x * c, y * c - 2 * c);
              lineCtx.lineTo(x * c, y * c - 2 * c + b);
              lineCtx.arc(
                x * c,
                y * c - 2 * c,
                b,
                Math.PI / 2,
                Math.PI * 2,
                true,
              );
            }
          }
        }
      }
    }
    lineCtx.fill();
    stackCtx.drawImage(lineCanvas, 0, 0);
  }
};
var stack = new Stack();
</script>
<!-- <script src=hold.js></script> -->
<script>
    function Hold() {
  this.piece;
}
Hold.prototype.draw = function() {
  clear(holdCtx);
  if (this.piece === 0 || this.piece === 3) {
    draw(
      pieces[this.piece].tetro,
      pieces[this.piece].x - 3,
      2 + pieces[this.piece].y,
      holdCtx,
    );
  } else {
    draw(
      pieces[this.piece].tetro,
      pieces[this.piece].x - 2.5,
      2 + pieces[this.piece].y,
      holdCtx,
    );
  }
};
var hold = new Hold();
</script>
<!-- <script src=preview.js></script> -->
<script>
    function Preview() {
  grabBag = this.gen();
}
Preview.prototype.init = function() {
  //XXX fix ugly code lolwut
  while (1) {
    this.grabBag = this.gen();
    if ([3, 4, 6].indexOf(this.grabBag[0]) === -1) break;
  }
  this.grabBag.push.apply(this.grabBag, this.gen());
  this.draw();
};
Preview.prototype.next = function() {
  var next;
  next = this.grabBag.shift();
  if (this.grabBag.length === 7) {
    this.grabBag.push.apply(this.grabBag, this.gen());
  }
  this.draw();
  return next;
  //TODO Maybe return the next piece?
};
/**
 * Creates a "grab bag" of the 7 tetrominos.
 */
Preview.prototype.gen = function() {
  var pieceList = [0, 1, 2, 3, 4, 5, 6];
  return pieceList.sort(function() {
    return 0.5 - rng.next();
  });
};
/**
 * Draws the piece preview.
 */
Preview.prototype.draw = function() {
  clear(previewCtx);
  for (var i = 0; i < 6; i++) {
    if (this.grabBag[i] === 0 || this.grabBag[i] === 3) {
      draw(
        pieces[this.grabBag[i]].tetro,
        pieces[this.grabBag[i]].x - 3,
        pieces[this.grabBag[i]].y + 2 + i * 3,
        previewCtx,
      );
    } else {
      draw(
        pieces[this.grabBag[i]].tetro,
        pieces[this.grabBag[i]].x - 2.5,
        pieces[this.grabBag[i]].y + 2 + i * 3,
        previewCtx,
      );
    }
  }
};
var preview = new Preview();
</script>
<!-- <script src=menu.js></script> -->
<script>
    var version = '0.1.8';
var setLoop;
var arrowReleased = true;
var arrowDelay = 0;

var key = {
  8: 'Backspace',
  9: 'Tab',
  13: 'Enter',
  16: 'Shift',
  17: 'Ctrl',
  18: 'Alt',
  19: 'Pause',
  20: 'Caps Lock',
  27: 'Esc',
  32: 'Space',
  33: 'PgUp',
  34: 'PgDn',
  35: 'End',
  36: 'Home',
  37: '←',
  38: '↑',
  39: '→',
  40: '↓',
  45: 'Insert',
  46: 'Delete',
  48: '0',
  49: '1',
  50: '2',
  51: '3',
  52: '4',
  53: '5',
  54: '6',
  55: '7',
  56: '8',
  57: '9',
  59: ';',
  61: '=',
  65: 'A',
  66: 'B',
  67: 'C',
  68: 'D',
  69: 'E',
  70: 'F',
  71: 'G',
  72: 'H',
  73: 'I',
  74: 'J',
  75: 'K',
  76: 'L',
  77: 'M',
  78: 'N',
  79: 'O',
  80: 'P',
  81: 'Q',
  82: 'R',
  83: 'S',
  84: 'T',
  85: 'U',
  86: 'V',
  87: 'W',
  88: 'X',
  89: 'Y',
  90: 'Z',
  96: '0kpad',
  97: '1kpad',
  98: '2kpad',
  99: '3kpad',
  100: '4kpad',
  101: '5kpad',
  102: '6kpad',
  103: '7kpad',
  104: '8kpad',
  105: '9kpad',
  106: '*',
  107: '+',
  109: '-',
  110: '.',
  111: '/',
  112: 'F1',
  113: 'F2',
  114: 'F3',
  115: 'F4',
  116: 'F5',
  117: 'F6',
  118: 'F7',
  119: 'F8',
  120: 'F9',
  121: 'F10',
  122: 'F11',
  123: 'F12',
  173: '-',
  187: '=',
  188: ',',
  190: '.',
  191: '/',
  192: '`',
  219: '[',
  220: '\\',
  221: ']',
  222: "'",
};

/**
 * Show and hide menus.
 */
var menus = document.getElementsByClassName('menu');
function menu(menuIndex) {
  for (var i = 0, len = menus.length; i < len; i++) {
    menus[i].classList.remove('on');
  }
  if (menuIndex !== void 0) menus[menuIndex].classList.add('on');
}

/**
 * Controls Menu
 */
var newKey,
  currCell,
  tempKey,
  controls = document.getElementById('controls'),
  controlCells = controls.getElementsByTagName('td');
// Give controls an event listener.
for (var i = 0, len = controlCells.length; i < len; i++) {
  controlCells[i].onclick = function() {
    // First check if we're already waiting for an input.
    if (currCell) {
      // TODO DRY
      // Make this into a function and call it when we press Esc.
      binds[currCell.id] = tempKey;
      currCell.innerHTML = key[tempKey];
    }
    tempKey = binds[this.id];
    this.innerHTML = 'Press key';
    currCell = this;
  };
}
// Listen for key input if a control has been clicked on.
addEventListener(
  'keyup',
  function(e) {
    // if click outside of cell or press esc clear currCell
    // reset binds button.
    if (currCell) {
      // Checks if key already in use, and unbinds it.
      for (var i in binds) {
        if (e.keyCode === binds[i]) {
          binds[i] = void 0;
          document.getElementById(i).innerHTML = binds[i];
        }
      }
      // Binds the key and saves the data.
      binds[currCell.id] = e.keyCode;
      currCell.innerHTML = key[e.keyCode];
      localStorage.setItem('binds', JSON.stringify(binds));
      currCell = 0;
    }
  },
  false,
);

/**
 * Settings Menu
 */
function settingsLoop() {
  if (arrowReleased || arrowDelay >= 6) {
    if (settingsArrow)
      settings[s] = settings[s] === 0 ? setting[s].length - 1 : settings[s] - 1;
    else
      settings[s] = settings[s] === setting[s].length - 1 ? 0 : settings[s] + 1;
    saveSetting(s);
    arrowReleased = false;
  } else {
    arrowDelay++;
  }
  setLoop = setTimeout(settingsLoop, 50);
}
var s;
var settingsArrow;
// TODO DRY this.
function arrowRelease() {
  resize();
  arrowReleased = true;
  arrowDelay = 0;
  clearTimeout(setLoop);
}
function left() {
  settingsArrow = 1;
  s = this.parentNode.id;
  this.onmouseup = arrowRelease;
  this.onmouseout = arrowRelease;
  settingsLoop();
}
function right() {
  settingsArrow = 0;
  s = this.parentNode.id;
  this.onmouseup = arrowRelease;
  this.onmouseout = arrowRelease;
  settingsLoop();
}

/**
 * LocalStorage functions
 */
function saveSetting(s) {
  localStorage['version'] = version;

  document.getElementById(s).getElementsByTagName('span')[0].innerHTML =
    setting[s][settings[s]];

  localStorage['settings'] = JSON.stringify(settings);
}
function loadLocalData() {
  if (localStorage['binds']) {
    binds = JSON.parse(localStorage.getItem('binds'));
    for (var i = 0, len = controlCells.length; i < len; i++) {
      controlCells[i].innerHTML = key[binds[controlCells[i].id]];
    }
  }
  // TODO When new version just update with new stuff, rest stays unchanged.
  if (localStorage['version'] !== version) {
    localStorage.removeItem('settings');
    localStorage.removeItem('binds');
  }
  if (localStorage['settings']) {
    settings = JSON.parse(localStorage.getItem('settings'));
  }
}

loadLocalData();
for (var s in settings) {
  var div = document.createElement('div');
  var b = document.createElement('b');
  var iLeft = document.createElement('i');
  var span = document.createElement('span');
  var iRight = document.createElement('i');

  div.id = s;
  b.innerHTML = s + ':';
  span.innerHTML = setting[s][settings[s]];
  iLeft.className = 'left';
  iRight.className = 'right';
  iLeft.onmousedown = left;
  iRight.onmousedown = right;

  set.appendChild(div);
  div.appendChild(b);
  div.appendChild(iLeft);
  div.appendChild(span);
  div.appendChild(iRight);
}
resize();
</script>
<!-- <script src=bg.js></script> -->
<script>
    //var bgCanvas = document.getElementById('bg');
//var bgCtx = bgCanvas.getContext('2d');
//var img = new Image();
//img.src = 'bg.jpg';
//
//function bgResize() {
//  var ar = window.innerWidth / window.innerHeight;
//
//  bgCanvas.width = 570 * ar;
//  bgCanvas.height = 570;
//
//  if (ar > 1) {
//    bgCtx.drawImage(img, 0, -285 * ar + 285, bgCanvas.width, 570 * ar);
//  } else {
//    bgCtx.drawImage(img, -285 + bgCanvas.width / 2, 0, 570, 570);
//  }
//}
//addEventListener('resize', bgResize, false);
//img.onload = function () {
//  bgCanvas.style.opacity = 1;
//  bgResize();
//}
var bgCanvas = document.getElementById('bg');
var vidAr = bgCanvas.offsetWidth / bgCanvas.offsetHeight;
function bgResize() {
  var ar = window.innerWidth / window.innerHeight;
  if (ar > vidAr) {
    bgCanvas.style.height = 'auto';
    bgCanvas.style.width = window.innerWidth + 'px';
    var height = bgCanvas.offsetHeight;
    var shift = (height - window.innerHeight) / 2;
    if (shift < 0) shift = 0;
    bgCanvas.style.top = -shift + 'px';
    bgCanvas.style.left = 0;
  } else {
    bgCanvas.style.width = 'auto';
    bgCanvas.style.height = window.innerHeight + 'px';
    var width = bgCanvas.offsetWidth;
    var shift = (width - window.innerWidth) / 2;
    if (shift < 0) shift = 0;
    bgCanvas.style.left = -shift + 'px';
    bgCanvas.style.top = 0;
  }
}
addEventListener('resize', bgResize, false);
bgResize();
</script>
<script>_gaq=[['_setAccount','UA-30472693-1'],['_trackPageview']];(function(d){var g=d.createElement('script'),s=d.scripts[0];g.src='//www.google-analytics.com/ga.js';s.parentNode.insertBefore(g,s)})(document)</script>